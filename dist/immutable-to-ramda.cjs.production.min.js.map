{"version":3,"file":"immutable-to-ramda.cjs.production.min.js","sources":["../src/transformers.ts","../src/utils.ts","../src/index.ts"],"sourcesContent":["import { types } from 'recast';\nimport { NodePath } from 'ast-types/lib/node-path';\nimport { namedTypes } from 'ast-types/gen/namedTypes';\nimport { pluck, propEq, isEmpty, difference, fromPairs } from 'ramda';\nimport {\n  FunctionCall,\n  GetTransformation,\n  ImmutableToRamdaMap,\n  TransformationMap,\n} from './types';\n// TODO: handle empty List(), Map()\n// TODO: handle space in literal string on get\n\nconst {\n  identifier,\n  stringLiteral,\n  callExpression,\n  memberExpression,\n  objectExpression,\n  arrayExpression,\n  importDeclaration,\n  importSpecifier,\n} = types.builders;\n\nconst functionsToImport: Set<string> = new Set();\n\nconst transformers: types.Visitor = {\n  visitCallExpression: function (path) {\n    const functionCallName: string = path.value.callee.property?.name;\n    const calleeNode = path.node.callee as namedTypes.MemberExpression;\n\n    const avoidThisExpr =\n      //@ts-ignore\n      !['R', 'this'].includes(calleeNode?.object?.name) &&\n      calleeNode?.object?.type !== 'ThisExpression';\n    const isSupported = Object.keys(transformersMap).includes(functionCallName);\n\n    if (isSupported && avoidThisExpr) {\n      const { ramdaFn, transformation } = transformersMap[functionCallName];\n\n      transformation({\n        path,\n        callee: calleeNode.object,\n        args: path.node.arguments,\n      });\n      functionsToImport.add(ramdaFn);\n    }\n\n    if (\n      ['fromJS', 'toJS', 'fromArray', 'List', 'Map'].includes(\n        path.value?.callee?.name\n      )\n    ) {\n      unwrapCaller({\n        path,\n        callee: path.value?.callee,\n        args: path.node.arguments,\n      });\n    }\n    this.traverse(path);\n  },\n};\n\nexport const importTransformer: types.Visitor = {\n  visitImportDeclaration: function (path) {\n    addImport(path);\n    this.traverse(path);\n  },\n};\n\nconst getterSetter =\n  (newFn: string, isGetter = true) =>\n  ({ path, callee, args }: FunctionCall) => {\n    const [propName] = args;\n    if (callee.type === 'ThisExpression') return;\n\n    const hasDefaultValue = args.length > 1 && isGetter;\n    const functionName = identifier(`${newFn}${hasDefaultValue ? 'Or' : ''}`);\n    const newArgs = hasDefaultValue ? args.reverse() : args;\n\n    const expr =\n      isGetter && propName.type === 'StringLiteral'\n        ? memberExpression(callee, identifier(propName.value))\n        : callExpression(functionName, [...newArgs, callee]);\n\n    path.replace(expr);\n  };\n\nconst getIn = ({ path, args, callee }: FunctionCall) => {\n  const [propsArray, ...defValue] = args;\n  const allLiteral = (x: any[]): x is types.namedTypes.StringLiteral[] =>\n    x.every(propEq('type', 'StringLiteral'));\n\n  if (!isEmpty(defValue)) {\n    const expr = callExpression(identifier('pathOr'), [\n      defValue[0],\n      propsArray,\n      callee,\n    ]);\n    path.replace(expr);\n    return;\n  }\n\n  const { elements } = propsArray;\n\n  const expr =\n    propsArray.type === 'ArrayExpression' && allLiteral(elements)\n      ? pluck('value', elements)\n          .map(identifier)\n          .reduce(\n            (acc, curr) =>\n              memberExpression.from({\n                object: acc,\n                property: curr,\n                optional: true,\n              }),\n            callee\n          )\n      : callExpression(identifier('path'), [propsArray, callee]);\n  path.replace(expr);\n};\n\nconst callerToArg =\n  (newFn: string) =>\n  ({ path, callee }: FunctionCall) => {\n    path.replace(callExpression(identifier(newFn), [callee]));\n  };\nconst callerAsLastArg =\n  (newFn: string) =>\n  ({ path, callee, args }: FunctionCall) => {\n    path.replace(callExpression(identifier(newFn), [...args, callee]));\n  };\nconst callerAsFirstArg =\n  (newFn: string) =>\n  ({ path, callee, args }: FunctionCall) => {\n    path.replace(callExpression(identifier(newFn), [callee, ...args]));\n  };\nconst unwrapCaller = ({ path, callee, args }: FunctionCall) => {\n  const expr = isEmpty(args)\n    ? //@ts-ignore\n      { Map: objectExpression([]), List: arrayExpression([]) }[callee.name]\n    : args[0];\n  path.replace(expr);\n};\n\nexport const nameAndTransform = (\n  ts: GetTransformation,\n  immutableRamdamap: ImmutableToRamdaMap\n) =>\n  fromPairs(\n    Object.entries(immutableRamdamap).map(([immutableFn, ramdaFn]) => [\n      immutableFn,\n      { ramdaFn, transformation: ts(ramdaFn) },\n    ])\n  );\n\nconst transformersMap: TransformationMap = {\n  ...nameAndTransform(callerAsLastArg, {\n    Map: 'fromPairs',\n    filterNot: 'reject',\n    zip: 'zip',\n    updateIn: 'modifyPath',\n    groupBy: 'groupBy',\n    update: 'modify',\n    findLast: 'findLast',\n    delete: 'dissoc',\n    deleteIn: 'dissocPath',\n    valueSeq: 'values',\n  }),\n  ...nameAndTransform(callerToArg, {\n    keySeq: 'keys',\n    flatten: 'flatten',\n    isEmpty: 'isEmpty',\n    flip: 'invertObj',\n  }),\n  ...nameAndTransform(callerAsFirstArg, { merge: 'mergeRight' }),\n  getIn: { ramdaFn: 'pathOr', transformation: getIn },\n  get: { ramdaFn: 'prop', transformation: getterSetter('prop') },\n  set: { ramdaFn: 'assoc', transformation: getterSetter('assoc', false) },\n  setIn: {\n    ramdaFn: 'assocPath',\n    transformation: getterSetter('assocPath', false),\n  },\n  sortBy: {\n    ramdaFn: 'sort',\n    transformation: ({ path, callee, args }: FunctionCall) => {\n      path.replace(\n        callExpression(identifier(`sort`), [\n          callExpression(identifier('ascend'), args),\n          callee,\n        ])\n      );\n      functionsToImport.add('ascend');\n    },\n  },\n  toJS: {\n    ramdaFn: '',\n    transformation: ({ path, callee }: FunctionCall) => {\n      path.replace(callee);\n    },\n  },\n};\n\nfunction addImport(path: NodePath<types.namedTypes.ImportDeclaration, any>) {\n  if (path.value.source.value !== 'ramda') return;\n  const imports = path.value.specifiers ?? [];\n  const importsIdentifiers = imports.map((s: any) => s?.imported?.name);\n  const newImportsIdentifiers = difference(\n    Array.from(functionsToImport),\n    importsIdentifiers\n  );\n\n  const newImports = newImportsIdentifiers\n    .filter(Boolean)\n    .map((f) => importSpecifier(identifier(f)));\n\n  const importExpr = importDeclaration(\n    [...imports, ...newImports],\n    stringLiteral('ramda')\n  );\n  path.replace(importExpr);\n}\n\nexport default transformers;\n","import { parse, print, visit } from 'recast';\nimport transformers, { importTransformer } from './transformers';\nimport { promises } from 'fs';\nimport { diffLines } from 'diff';\nimport { parseSync } from '@babel/core';\nimport chalk from 'chalk';\nimport signale from 'signale';\n\nconst parseFile = async (path: string) =>\n  promises\n    .readFile(path, 'utf-8')\n    .then((src) => ({\n      src,\n      ast: parse(src, {\n        parser: {\n          parse: (source: string) =>\n            parseSync(source, {\n              plugins: [[`@babel/plugin-syntax-typescript`, { isTSX: true }]],\n              overrides: [\n                {\n                  test: [`**/*.ts`, `**/*.tsx`],\n                  plugins: [\n                    [`@babel/plugin-syntax-typescript`, { isTSX: true }],\n                  ],\n                },\n              ],\n              filename: path,\n              parserOpts: {\n                tokens: true,\n              },\n            }),\n        },\n      }),\n    }))\n    .catch((err: any) => {\n      signale.error(`unable to parse ${path}`);\n      signale.error(err);\n    });\n\nconst transformSource = async (path: string) => {\n  const code = await parseFile(path);\n  if (!code) return;\n  const { src, ast } = code;\n  visit(ast, transformers);\n  visit(ast, importTransformer);\n  const newSrc = print(ast).code;\n  return src === newSrc ? false : { src, newSrc };\n};\n\nexport const printDiff = async (path: string) => {\n  const code = await transformSource(path);\n  if (!code) return;\n  diffLines(code.src, code.newSrc).forEach((part) => {\n    const color = part.added ? 'green' : part.removed ? 'red' : null;\n    if (color) console.log(chalk[color](part.value));\n  });\n};\n\nexport const rewriteSource = async (path: string) => {\n  const code = await transformSource(path);\n  if (!code) return;\n  const newFh = await promises.open(path, 'w');\n  newFh.writeFile(code.newSrc);\n  signale.success(`${path} written`);\n};\n","import { program } from 'commander';\nimport { printDiff, rewriteSource } from './utils';\n\nprogram.option('--dry');\nconst args = program.parse(process.argv);\n\nargs.args.forEach(program.opts().dry ? printDiff : rewriteSource);\n"],"names":["types","builders","identifier","stringLiteral","callExpression","memberExpression","objectExpression","arrayExpression","importDeclaration","importSpecifier","functionsToImport","Set","transformers","visitCallExpression","path","functionCallName","value","callee","property","_path$value$callee$pr","name","calleeNode","node","avoidThisExpr","includes","object","_calleeNode$object","_calleeNode$object2","type","Object","keys","transformersMap","ramdaFn","transformation","args","arguments","add","_path$value","_path$value$callee","unwrapCaller","_path$value2","this","traverse","importTransformer","visitImportDeclaration","source","imports","specifiers","importsIdentifiers","map","s","imported","_s$imported","newImports","difference","Array","from","filter","Boolean","f","importExpr","replace","addImport","getterSetter","newFn","isGetter","propName","hasDefaultValue","length","functionName","newArgs","reverse","expr","callerToArg","callerAsFirstArg","isEmpty","Map","List","nameAndTransform","ts","immutableRamdamap","fromPairs","entries","filterNot","zip","updateIn","groupBy","update","findLast","delete","deleteIn","valueSeq","keySeq","flatten","flip","merge","getIn","propsArray","defValue","elements","every","propEq","pluck","reduce","acc","curr","optional","get","set","setIn","sortBy","toJS","parseFile","promises","readFile","then","src","ast","parse","parser","parseSync","plugins","isTSX","overrides","test","filename","parserOpts","tokens","err","signale","error","transformSource","_context2","code","visit","newSrc","print","printDiff","_context3","diffLines","forEach","part","color","added","removed","console","log","chalk","rewriteSource","_context4","open","writeFile","success","program","option","process","argv","opts","dry"],"mappings":"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"}